---
principle_creation_guide: |
  ## Structure Pattern

  1. **Title**: Clear, action-oriented principle name
  2. **Core concept**: What's being treated as what (one sentence)
  3. **Implementation**: How it works in practice (2-3 sentences with specifics)
  4. **Benefit & constraint**: The value and boundary (one sentence with "so long as")

  ## Tone Requirements

  - **Direct and technical**: Conversational but precise, easy to scan
  - **Functional descriptions**: Use practical terms over forced metaphors
  - **Specific examples**: Include implementation details in parentheses
  - **One paragraph maximum**: 3-5 sentences total per principle

  ## Tone Counter-Example (What NOT to do)

  **Bad Example** (academic jargon, no actionable guidance):
  > "The implementation paradigm leverages a compositional architecture whereby discrete units of functionality are encapsulated within boundary-defined containers that facilitate loose coupling through standardized interface protocols."

  **Problems**: Academic jargon, no concrete guidance, missing the "so long as" constraint, not scannable.

  ## Quality Checklist

  **Definition of Done Criteria**:
  - [ ] Clear principle name that indicates action/concept
  - [ ] Explains what and how in practical terms
  - [ ] Includes benefit and constraint ("so long as" clause)
  - [ ] One paragraph, scannable format
  - [ ] Provides actionable guidance for decision-making

  ## Example Variables

  - **Subjects**: Components, Context packages, Names, Interfaces
  - **Descriptions**: bricks, focused toolkits, descriptive labels, precious resources
  - **Specifications**: clear interface, boundary definition, descriptive contract
  - **Constraints**: interface contract, context boundary, naming clarity, explicit separation
---

# Design Principles

Always follow these design principles when researching, planning, and implementing. Use these to create guardrails for yourself and resolve ambiguous requests. When the user makes a request that breaks these principles, remind them of these principles and ask for clarification then STOP and wait for a response.

## Component Modularity

Components (software, business logic, workflows) function as self-contained 'bricks'. Each brick has a clear specification (its 'blueprint') that includes its public interface (inputs), dependencies (files to read, tech stack imports), processing, and outputs. Code, prompts, and other project material result from this blueprint. This lets any brick be safely refactored or regenerated by an AI without impacting the wider system, so long as its interface contract remains intact.

## Just Enough Context

Context packages function as focused toolkits. Each kit has a clear boundary that includes its target goal, relevant files (paths and line ranges), dependencies (imports, related functions), and exclusions (what to ignore). Documentation, prompts, and context materials result from this boundary specification. This lets any AI task complete efficiently without information overload or distractions, so long as the context provides enough signal for successful completion.

## Self-Contained Naming

Names (files, functions, classes, variables) function as descriptive labels. Each label has a clear description that includes its system scope, operation type, and intended outcome. Self-explanatory identifiers result from this description. This lets any human or AI understand the purpose immediately without reading code or consulting documentation, so long as the name provides enough detail to remove confusion.

## Deterministic Offloading

LLM interactions are treated as precious semantic resources. Each interaction has a clear separation between deterministic operations (file I/O, search patterns, syntax transformations) and semantic tasks (understanding intent, making design decisions, generating contextual content). Tools handle the mechanical work—reading files, running searches, executing commands—while the LLM focuses purely on interpretation and generation. This provides maximum cognitive bandwidth for complex reasoning without wasting context on predictable operations, so long as the boundary between deterministic and non-deterministic work stays explicit.

## Don't Repeat Yourself (DRY)

Every piece of knowledge (functionality, directives, context) should have a single source of truth. Each piece has a single definition - whether that's a function, a markdown file, or a configuration. Everything else just points to it. This prevents copy-paste drift, removes conflicting directives, and makes maintenance easier across code, prompts, and documentation, so long as you reference the original instead of duplicating it.

## Minimize Token/Resource Waste

Token usage and computational resources are treated as precious constraints. Each prompt and specification has a lean profile that includes only essential instructions (no redundant explanations), minimal viable examples (one good example beats three mediocre ones), and direct language (skip the preamble, get to the point). Trimmed prompts and focused interfaces result from this constraint-aware design. This maximizes available context for actual work while reducing processing overhead, so long as clarity and completeness aren't sacrificed for brevity's sake.

## Prompt Clarity

Prompts (agents, tasks, workflows) are designed to reduce conflicting directives, reduce ambiguities, increase ease of maintenance, and increase clarity. Each instruction lives in one place (no duplicates), uses specific language (no vague terms like "handle"), and states exactly what it does (no guessing). This means when you need to fix something, you know where to look, what to change, and won't find three different versions saying different things, so long as every prompt maintains a single source of truth.
