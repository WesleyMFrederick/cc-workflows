# CitationValidator Implementation Guide

This guide provides the Level 4 (Code) details for refactoring the **`CitationValidator`** component as part of user story `us1.5`. It includes the component's updated structure, pseudocode for its refactored logic, its formal data contracts, and a strategy for testing.

## Problem

Links and anchors identified by the `MarkdownParser` are purely syntactic constructs. There's no guarantee that a link's path points to an existing file or that its anchor corresponds to a real header or block in the target document. The system requires a dedicated component to perform this semantic validation and report the status of each link.

## Solution

The **`CitationValidator`** component is responsible for the semantic validation of links. It consumes the `Link Objects` generated by the `MarkdownParser` (via the `ParsedFileCache`). For each link, it verifies that the target file exists and, if an anchor is specified, that the anchor is present in the target document's list of `Anchor Objects`. It produces a **`ValidationResult`** object that details the status of every link (`valid`, `warning`, or `error`) and provides actionable suggestions for any failures.

## Structure

The `CitationValidator` is a class that depends on the `ParsedFileCache` (for retrieving parsed documents) and the `FileCache` (for legacy path resolution). It exposes a primary public method, `validateFile()`, which orchestrates the validation process.

```mermaid
classDiagram
    direction LR

    class CitationValidator {
        -parsedFileCache: ParsedFileCacheInterface
        -fileCache: FileCacheInterface
        +validateFile(filePath: string): Promise~ValidationResult~
        -validateSingleLink(link: Link): Promise~object~
        -validateAnchorExists(link: Link): Promise~object~
    }

    class ParsedFileCache {
        <<interface>>
        +resolveParsedFile(filePath: string): Promise~ParserOutputContract~
    }

    class FileCache {
        <<interface>>
        +resolveFile(filename: string): ResolutionResult
    }

    class ValidationResult {
        +summary: object
        +results: object[]
    }

    class ParserOutputContract {
      +filePath: string
        +content: string
        +tokens: object[]
        +links: Link[]
        +anchors: Anchor[]
    }
    
    class ResolutionResult {
      +found: boolean
      +path: string
    }

    CitationValidator ..> ParsedFileCache : depends on
    CitationValidator ..> FileCache : depends on
    CitationValidator --> ValidationResult : returns
    ParsedFileCache --> ParserOutputContract : returns
    FileCache --> ResolutionResult : returns
```

1. [**ParserOutputContract**](Markdown%20Parser%20Implementation%20Guide.md#Data%20Contracts): The data object consumed by the validator to get link and anchor lists.
2. [**ParsedFileCache**](ParsedFileCache%20Implementation%20Guide.md): The dependency used to retrieve `ParserOutputContract` objects efficiently.
3. [**FileCache**](../features/20251003-content-aggregation/content-aggregation-architecture.md#Citation%20Manager.File%20Cache): The dependency used for short filename lookups.
4. [**ValidationResult**](CitationValidator%20Implementation%20Guide.md#ValidationResult%20JSON%20Schema): The composite object returned by the validator.
5. [**CitationValidator**](CitationValidator%20Implementation%20Guide.md): The class that orchestrates the validation process.

## Public Contracts

### Input Contract
The component's constructor accepts two dependencies:
1. An implementation of a **[`ParsedFileCache interface`](ParsedFileCache%20Implementation%20Guide.md#Public%20Contracts)**
2. An implementation of a [**`FileCache interface`**](../features/20251003-content-aggregation/content-aggregation-architecture.md#Citation%20Manager.File%20Cache)

The primary public method, `validateFile()`, accepts one argument:
1. **`filePath`** (string): The absolute path to the source markdown file to validate.

### Output Contract
The `validateFile()` method returns a `Promise` that resolves with a **`ValidationResult`** object. This object has the following structure:
- **`summary`** (object): An object containing counts of `total`, `valid`, `warning`, and `error` links.
- **`results`** (array): An array where each item is a detailed result object for a single link, including its `status`, `line`, `column`, and any `error` or `suggestion` messages.

## Pseudocode

This pseudocode follows the **MEDIUM-IMPLEMENTATION** abstraction level, showing the refactored logic that uses the new caching layer.

TypeScript

```tsx
// The CitationValidator class, responsible for the semantic validation of links.
class CitationValidator is
  private field parsedFileCache: ParsedFileCacheInterface
  private field fileCache: FileCacheInterface

  // The constructor accepts its cache dependencies.
  constructor CitationValidator(pCache: ParsedFileCacheInterface, fCache: FileCacheInterface) is
    // Integration: These dependencies are provided by the factory at runtime.
    this.parsedFileCache = pCache
    this.fileCache = fCache

  // The primary public method that orchestrates the validation of a source file.
  public async method validateFile(filePath: string): ValidationResult is
    // Boundary: The validator's first action is to get the parsed source file from the cache.
    field sourceFileContract = await this.parsedFileCache.resolveParsedFile(filePath)

    field validationPromises = new array of Promise
    foreach (link in sourceFileContract.links) do
      // Pattern: Concurrently validate all links found in the source document.
      validationPromises.add(this.validateSingleLink(link))
    
    field results = await Promise.all(validationPromises)

    return this.generateSummary(results)

  // Validates a single Link Object.
  private async method validateSingleLink(link: Link): object is
    // Decision: Check if the target file path was successfully resolved by the parser.
    if (link.target.path.absolute == null) then
      // The parser already determined the path is invalid.
      return { status: "error", error: "File not found: " + link.target.path.raw, ... }

    // Decision: Does the link have an anchor that needs validation?
    if (link.anchorType == "header" || link.anchorType == "block") then
      return await this.validateAnchorExists(link)
    else
      // This is a full-file link; path existence is sufficient.
      return { status: "valid", ... }

  // Validates that an anchor exists in its target document.
  private async method validateAnchorExists(link: Link): object is
    try
      // Boundary: Retrieve the PARSED TARGET FILE from the cache.
      // This is the core of the us1.5 optimization.
      field targetFileContract = await this.parsedFileCache.resolveParsedFile(link.target.path.absolute)
      
      // Check if the target anchor ID exists in the target file's list of anchors.
      field anchorExists = targetFileContract.anchors.some(anchor => anchor.id == link.target.anchor)

      if (anchorExists) then
        return { status: "valid", ... }
      else
        // Pattern: If the anchor is not found, generate helpful suggestions.
        field suggestion = this.generateAnchorSuggestions(link.target.anchor, targetFileContract.anchors)
        return { status: "error", error: "Anchor not found", suggestion: suggestion, ... }
        
    catch (error) is
      // Error Handling: If the target file can't be parsed (e.g., doesn't exist), propagate the error.
      return { status: "error", error: error.message, ... }
```

## `ValidationResult` JSON Schema

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://cc-workflows.com/validation-result.schema.json",
  "title": "Validation Result Contract",
  "description": "The complete output from the CitationValidator's validateFile() method, containing a summary and detailed results for each link.",
  "type": "object",
  "properties": {
    "file": {
      "description": "The absolute path of the file that was validated.",
      "type": "string"
    },
    "summary": {
      "description": "An object containing statistics about the validation run.",
      "$ref": "#/$defs/summaryObject"
    },
    "results": {
      "description": "An array of result objects, one for each link found in the source file.",
      "type": "array",
      "items": {
        "$ref": "#/$defs/singleValidationResult"
      }
    }
  },
  "required": [
    "file",
    "summary",
    "results"
  ],
  "$defs": {
    "summaryObject": {
      "title": "Summary Object",
      "type": "object",
      "properties": {
        "total": {
          "description": "The total number of links that were validated.",
          "type": "integer",
          "minimum": 0
        },
        "valid": {
          "description": "The number of links with a 'valid' status.",
          "type": "integer",
          "minimum": 0
        },
        "warnings": {
          "description": "The number of links with a 'warning' status.",
          "type": "integer",
          "minimum": 0
        },
        "errors": {
          "description": "The number of links with an 'error' status.",
          "type": "integer",
          "minimum": 0
        }
      },
      "required": [
        "total",
        "valid",
        "warnings",
        "errors"
      ]
    },
    "singleValidationResult": {
      "title": "Single Validation Result",
      "description": "The detailed validation status for a single link.",
      "type": "object",
      "properties": {
        "line": {
          "description": "The line number of the link in the source file.",
          "type": "integer",
          "minimum": 1
        },
        "column": {
          "description": "The column number on the line where the link begins.",
          "type": "integer",
          "minimum": 1
        },
        "citation": {
          "description": "The raw markdown string of the link.",
          "type": "string"
        },
        "status": {
          "description": "The validation status for the link.",
          "type": "string",
          "enum": [
            "valid",
            "warning",
            "error"
          ]
        },
        "linkType": {
          "description": "The markdown syntax style of the link.",
          "type": "string",
          "enum": [
            "markdown",
            "wiki"
          ]
        },
        "error": {
          "description": "A detailed error message, present only if status is 'error'.",
          "type": [
            "string",
            "null"
          ]
        },
        "suggestion": {
          "description": "A human-readable suggestion for how to fix the issue.",
          "type": [
            "string",
            "null"
          ]
        },
        "pathConversion": {
          "description": "A structured object with a suggested path correction, present only for 'warning' statuses related to pathing.",
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "type": {
              "type": "string",
              "const": "path-conversion"
            },
            "original": {
              "type": "string"
            },
            "recommended": {
              "type": "string"
            }
          },
          "required": [
            "type",
            "original",
            "recommended"
          ]
        }
      },
      "required": [
        "line",
        "column",
        "citation",
        "status",
        "linkType"
      ]
    }
  }
}
```

## Testing Strategy

```tsx
// Test pattern: BDD-style behavioral validation for the refactored component.
class CitationValidatorTests is

  // Test the successful validation of a document with valid links.
  method test_validation_shouldSucceedForValidLinks(): TestResult is
    // Given: A mock ParsedFileCache that returns valid ParserOutputContracts for a source and target file.
    // When: The validator's 'validateFile()' method is called on the source file.
    // Then: The returned ValidationResult object should report all links as 'valid'.
    // Validation: The mock ParsedFileCache's 'resolveParsedFile' method should have been called for both the source and target files.

  // Test the detection of a broken link due to a missing anchor.
  method test_validation_shouldFailForMissingAnchor(): TestResult is
    // Given: A mock ParsedFileCache where the target document's 'anchors' array does not contain the required anchor.
    // When: 'validateFile()' is called.
    // Then: The resulting ValidationResult object should report the link's status as 'error'.
    // Validation: The 'suggestion' field should contain helpful text based on the available anchors.

  // Test the core performance optimization of the caching layer.
  method test_caching_shouldRequestTargetFileOnlyOnce(): TestResult is
    // Given: A source document with multiple links pointing to the SAME target file.
    // Given: A mock ParsedFileCache.
    // When: 'validateFile()' is called on the source document.
    // Then: The mock ParsedFileCache's 'resolveParsedFile' method should have been called only ONCE for the target file.
    // Boundary: Verifies that the validator correctly leverages the cache to prevent redundant parsing.
```
